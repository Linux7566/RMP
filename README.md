# Server

1НФ — это базовое требование к организации данных в реляционной базе данных, которое означает, что каждая ячейка должна содержать одно атомарное (неделимое) значение,
отсутствует повторяющиеся группы атрибутов, а в каждой таблице есть первичный ключ.
2НФ — это требование к структурам баз данных, которое гласит: 
таблица должна быть в первой нормальной форме (1НФ) и все неключевые столбцы (атрибуты) должны полностью зависеть от всего составного первичного ключа 
3НФ — это принцип проектирования баз данных, который требует, чтобы таблица находилась во 2НФ и не содержала транзитивных зависимостей.
Это означает, что все неключевые атрибуты должны зависеть только от первичного ключа, а не от других неключевых атрибутов.
В терминологии таблицы называются сущностями. Значение первых строк в каждой таблице это определённый критерий сущности. Атрибуты.
SQL запросы делят на след. основные типы:
1. DDL запрос - операторы определения данных, которые работают с целыми таблицами. (CREATE, USE)
2. DML запрос - содержит в себе операторы манипуляции данными, которые работают с содержимым тиаблицы. (UPDATE, SELECT, DELETE, INSERT)
3. DCL запрос - операторы определения доступа к данным для разных пользователей. (GRANT, DENY)
4. TCL запрос - язык управления транзакциями, сериями команд, которые выполняются поочерёдно. Если хотя бы одна из команд не выполнена, все последующие тоже отменяются. 
Пример: оплата, подтвердить платёж. 
BEGIN TRANSACTION - начало транзакции, 
COMMIT TRANSACTION - изменение команд в цепочке, 
SAVE TRANSACTION - промежуточная точка сохранения внутри транзакции. 

ТИПЫ ДАННЫХ
Первичный ключ должен быть:
целочисленный тип данных, не отрицательное и не 0, должен являться автоинкрементом
Запись не должна быть пустой и не должна равняться 0 (NOT NULL)
Наиболее подходящий тип данных для первичных ключей это serial/smallserial/bigserial
Если кол-во символов примерно известно заранее и составляет не более 255 символов, то правильнее использовать тип данных varchar. Если нужно ограничить до 10 символов, то varchar(10).
Текстовый тип данных, когда неизвестно кол-во символов, ставится динамическая величина text.
Вещественное число с указанной точностью numeric
для целочисленных значений без автоинкремента используются типы данных integer/smallint/bigint
Внешний ключ должен описываться с типом данных integer
даты рождения, регистрации, оформление заказа используется timestamp 
запросы:
CREATE TABLE public.clients

чтобы добавить атрибут в статус в таблицу ордерс необходимо выполнить следующий SQL запрос:
alter table orders 
add check (status in ('открыт', 'закрыт'))

запрос вывести список всех клиентов с их данными:
select * from clients 

запрос с условием. вывести все закрытые заказы:
select * from orders 
where status = 'закрыт'

вывести все товары дороже 80 рублей:
select * from products 
where price >80

условие с фильтрацией. вывести имена и рейтинг клиентов с рейтингом выше 4.1 и отсортировать в порядке увеличения рейтинга:
select name, rating from clients
where rating > 4.0
order by rating desc(максимальное значение сверху)/asc(минимальное значение сверху) 


create or replace function update_order_item_price()
returns trigger as $$
	begin new.price :=(
		select price from products where product_id = new.product_id
		) * new.count;
		return new;
		end; 
		$$ language plpgsql;

create trigger trg_calculate_order_item_price
before insert or update on order_items
for each row execute function update_order_item_price();


Модуль 4
клиент серверная разработка интернет магазин
клиент:
запросы HTTP; ответы

сервер - физическая или виртуальная высокопроизводительная машина, которая должно работать 24/7 и иметь доступ к интернету + отдельное запущенное приложение (в нашем сучае Node.JS): 
бизнес логика; сервер; запросы HTTP
Node.js платформа для JS, построенная на движке V8, которая позваляет запускать JS код вне браузер, на сервере и на любом компьютере
ключевые особенности и принципы при работе с node.js:
1. асинхронность и событийно-ориентированная архитектура 
1.1. не блокирующий ввод/вывод
когда серверу нужно выполнить операцию ввода или вывода (прочитать файл с диска, сделать запрос к БД, отправить сетевой запрос) оно не ждёт её завершения.
вместо этого оно продолжает выполнять другой код. как только операция завершается, вызвается специальная функция обработчик callback
1.2. однопоточность с циклом собитий (ивент луп) 
в основе js лежит однопоточная модель. однако это не значит, что он может делать только одну задачу за раз. цикл событий - это механизм,
который постоянно провряет, завершились ли какие-либо асинхронные операции. если операция завершена он ставил её callback в очередь на выполнение.
2. NPM (nodepacadgem) nodejs поставляется со своим менеджером пакетов npm, это огромная эко система открытых библиотек и инуструментов, которые
можно легко установить и использовать в своём проекте. какие работы выполняются на сервере при клиент серверной разработке:
1. создание, настройка http сервера.
установка модуля express.js для настройки сервера. упростит разработку и настройку сервера. 
создание экземпляра приложения и определение порта, на котором сервер будет принимать входящие и исходящие подключения.
2. подключение к БД. для того чтобы подключимть js к бд испоьзуется модуль pg. на этапе подключения к бд происходит настройка и подключение к субд с использованием соответсвующего драйвера (pg)
или orm/odm систиемы. создание конфигурационного файла БД ( в нём укащываем параметры подключения к бд).
3. рвзрвботка промежуточных обработчиков. разрабатываются компоненты, которые обрабатывают входящие http запросы до того, как они достигнут маршрутов (по другому называются middleware) 
4. определение моделей данных. разработка модуля, который описывает структуры данных, которые будут храниться в бд (таблицы, коллекции, поля, типы данных, связи)
это делается с помощью SQL скриптов на сервере, либо через ORM/ODM модули.
5. создание маршрутов (routes и api-endpoints) разработка обработчиков для различных http запросов (get/ post/ put/ delete) 
по определённым url адресам (endpoint). куаждый маршрут соответсвтуеь конкретной операции crud.
6. реализация контроллеров (controllers) написание функий - обработчиков, которые привязаны к маршрутам.
эти функции содержэат бизнес логику: получают данные из запроса, взаимодейтсвуют с бд (через модели), отправляют ответ клиенту. 
БД:
запросы SQL
хорошим тоном является разработка доп модулей, отвечающих за обработку ошибок и валидацию данных, настройка переменных окружения.

HTTP методы
определяют действие,которое клиент хочет выполнить с ресурсом на сервере. они являются основной семантикой restful api.
1. метод get (получить)это безопасный метод для получения информации из бд. пример маршрута для получения списка всех пользователей: get /api/ clients
получить данные конкретного пользователя: get /api/ clients/1 (id)
2. метод post (создать/отправить) небезопастный (меняет состояние сервера, неидентпотентный (2 одинаковых запроса создадут 2 ресурса. данные передаются в теле запроса (body)) 
пример маршрута для создания нового пользователя: post/api/ clients/1
3. put метод (обновить/заменить)/ полное обновление или замена существующего ресурса. небезопасный и иденпотентный запрос. 
put/api/clients/1
4. patch метод (частично обновить) применяется для того, чтобы изменить данные у конкретного пользователя.
5. delete метод (уцдаление) удаление указанного ресурса. небезопастный и иденпотентный delete /api/ clients/1

коды ответов сервера
это трёхзначные числа,(чаще в диапазоне от 100 до 503) которые сервер отправляет в ответ на http запрос. они сообщают клиенту результат выполнения операции и группируются по первой цифре 
1xx это информационный. сотый ответ, сервер готов принять т запроса
2хх это сообщение об успехе. запрос был успешно обработан.
200 get put patch. 201 post, 204 no content после delete
3хх перенаправление или редирекшн. чтоб сообщить клиенту, что для завершения запроса необходимо сделать дополнительное действие (перейти по другому адресу). 
301 запрашиваемы ресур был перемещён по новому адресу.
4хх ошибка на клиенте. клиент сделал неправильный запрос. 
400 плохой запрос, сервер не может отработать запрос из за некоректного синтаксиса. 401 для неавторизованных пользователей, для доступа пользователю требуется аудентификация. 403 сервер принял запрос, но отказывается авторизовывать. 404 сервер не может найти запрашиваемый ресурс. 429 клиент отправил слишком много запросов за короткое время.
5хх ошибки сервера. сервер не смог выполнить запрос по своей вине. 
500 ошибка возникает из за багов в коде. 502 плохое соединение между сервером, бд. 503 срвер временно перегружен. 


NodeMon 
сиквелайс - ORM система, которая позваляет создавать модели данных, которые на языке js позвляют описать сущности бд (наши таблицы и атрбиты в них)

async function func(){
    try {
        const result = await allert ("5");
    }
    catch (error) {
    }
}
async перед объявлением функции делает 2 важные вещи
1. возвращает результат в виде promise
2. позволяет использовать await внутри функции 
await заставляет js ждать пока promise не будет выполнен или отклонён
try любая ошибка будет перехваена в блок catch

таблица создаётся тегом <table>, шапка <thead>, тело <tbody>, подвал <tfoot>.
В thead пишутся заголовки колонок. в tbody пишутся все значения колонок. В tfoot пишутся результаты подсчётов.
Строка создаётся с помощью тега <tr>. <th>(заголовочная ячейка)/<td> - создаются ячейки.

HTML:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="styles.css">
</head>
<table>
    <thead id="myTable_thead">
        <tr>
            <th>id</th>
            <th>name</th>
            <th>age</th>
        </tr>
    </thead>
    <tbody id="test">

    </tbody>
</table>
<body>
<script src="./script.js"></script>
</body>
</html>



Скрипт:
const dataSet = [
    {id: 1, name: "Иванов А.А.", age: 30},
    {id: 2, name: "Смирнова Л.В.", age: 12},
    {id: 3, name: "Петрова С.П.", age: 54}
];

/*const fillTbody = (dataSet)=> {
    const tbody = document.getElementById("test");
    dataSet.forEach(element => {
        const tr = tbody.insertRow()
        tr.innerHTML = `
        <td>${element.id}</td>
        <td>${element.name}</td>
        <td>${element.age}</td>
        `;
    });
}
fillTbody(dataSet);*/

минусы данного кода:
1.данный код будет работать и он является хорошим примером, но только в случае, если структура массива с данными не будет меняться(не будут появляться новые атрибуты)
2. потенциальная уязвимость при использовании внешних данных. если вдруг в данных окажется строка с html тегами, то при вставке через innerhtml этот код выполнится
это называется XSS уязвимость. не рекомендуется адресовывать данные через innerhtml.

_______________________________________________________________________________

более безопасный и контролируемый способ (создание элементов через createElement, appendChild и запись данных с помощьб textContent
этот вариант решает проблему XSS и даёт больше контроля над каждым элементом. 
основная суть подхода зашить каждую ячейку в отдельную переменную и присвоить ей значение из массива методом textContent, так как он безопастный.


/*const fillTbody = (dataSet)=> {
    const tbody = document.getElementById("test");
    dataSet.forEach(element=> {
        const tr = document.createElement("tr");

        const tdId = document.createElement("td");
        tdId.textContent = element.id;
        tr.appendChild(tdId);
        
        const tdName = document.createElement("td");
        tdName.textContent = element.name;
        tr.appendChild(tdName);

        const tdAge = document.createElement("td");
        tdName.textContent = element.name;
        tr.appendChild(tdAge);

        tbody.appendChild(tr);

    });
}
fillTbody(dataSet);

____________________________________________________________________________

const createTable = (dataSet)=> { 
    dataSet.forEach(element=> {
        const tbody = document.getElementById("test");
        const row = document.createElement("tr");

    const cellId = document.createElement ('td');
    cellId.textContent = element.id
    row.appendChild(cellId);

    const cellName = document.createElement ('td');
    cellName.textContent = element.name
    row.appendChild(cellName);

    const cellAge =  document.createElement ('td');
    cellAge.textContent = element.age
    row.appendChild(cellAge);

    tbody.appendChild(row);
    });
}
createTable(dataSet);


добавить вторую функцию, которая будет срабатывать при нажатии на кнопку поиск (в HTML разметке), 
будет брать строковое значение из input поля и применять фильтр к данным для заполнения таблицы.
добавить кнопку удаления фильтра (возвращние данных в исходный вид).
input, value 
filter (создаёт новый массив)
includes
string (в строковый тип данных)

let originalData = [...dataSet];
let filteredData = [...dataSet];

// Функция для создания таблицы
const tableParser = (dataSet) => {
    const thead = document.getElementById('myTable_thead');
    const tbody = document.getElementById('myTable_tbody');
    
    // Очищаем таблицу
    thead.innerHTML = '';
    tbody.innerHTML = '';
    
    // Создаем заголовки
    const headerRow = thead.insertRow();
    const headers = Object.keys(dataSet[0]);
    
    headers.forEach(headerKey => {
        const cell = headerRow.insertCell();
        cell.textContent = headerKey;
    });

    // Заполняем таблицу данными
    dataSet.forEach(element => {
        const bodyRow = tbody.insertRow();
        headers.forEach(headerKey => {
            const cell = bodyRow.insertCell();
            cell.textContent = element[headerKey];
        });
    });
}

// Функция для применения фильтра
function applyFilter() {
    const filterValue = document.getElementById('filterInput').value.toLowerCase().trim();
    
    if (filterValue === '') {
        // Если поле пустое, показываем все данные
        filteredData = [...originalData];
    } else {
        // Фильтруем данные
        filteredData = originalData.filter(item => {
            // Ищем совпадения во всех полях объекта
            return Object.values(item).some(value => 
                String(value).toLowerCase().includes(filterValue)
            );
        });
    }
    
    // Обновляем таблицу
    tableParser(filteredData);
}

// Функция для сброса фильтра
function clearFilter() {
    document.getElementById('filterInput').value = '';
    filteredData = [...originalData];
    tableParser(filteredData);
}

// Инициализация таблицы при загрузке страницы
tableParser(dataSet);

_________________________________________________________________________________________________________________________________\



index.js - это основной файл для запуска сервера. в нём импортируются модули express и dotenv
npm init -y
npm install express pg
pg-hstor cors sequelize dotenv -D nodemon

package.json
"dev": "nodemon index.js,"
server > index.js
require('dotenv').config() - метод commonJS
import 'dotenv/config' // ES modules
Есть 2 основных способа импорта и экспорта модулей. 
ESM - более современный формат. Он соответсвтует последним стандартам ECMAscript
import 'dotenv/config' // ES modules
import { EmptyResultError } from 'sequelize'

/* commonJS
const express = require('express');
const {Router} = require('express');

vodule.exports = myfune;
vodule.exports = {Class1, Class2};
exports.myFunc = () => {...}
*/

/*ESM
import express/{Router} from 'express'
import * as models from './models'

export default myClass
export {Class1, Class2}
export const myFunc = () => {};

- файл конфигурации БД. в нём прописываются параметры подключению к БД. при этом подключение БД происходит с помощью объекта модуля сиквелайз

в папке models создаём файл models.js где будут описываться модели данных = таблицы = сущности

SERIAL -> INTEGER 
+ autoIncrement
+ primaryKey
__________________
VARCHAR(n) -> DataTypes.
STRING(n)
Numeric(p,s) -> DataTypes.
DECIMAL(p,s)

use - это метод настройки промежуточного по, используемого маршрутами объекта сервера express. 
express.json - это встроенная функция разбирающая входящие запрос в объект формата json.
Функция get - принимает в себя два аргумента. 1) http метод (get, post, put, delete и т.д.). 2) путь на сервере (/).
и стрелочная функция hendler function, которая выполняется при совпадения маршрута.
Reg - это объект запроса, т.е. то, что прислал клиент. Из него читаются данные.
Res - объект ответа, в него пишем данные в ответ клиенту.
get запрос работает, но его необходимо оформить правильным способом. Сделать метод асинхронным, обезапасить код, добавить обработку ошибок, сделать маршрут более коректным.
app.use(cors());
app.use(express.json());

const {Client} = models;

app.get ('/api/getclients', async (reg, res) => {
    try {
        const getClients = await Client.findAll();
        res.status(200).json(getClients);
    } catch (error) {
        res.status(500).json({message:'ошибка сервера, при получении данных'});
    }
});
Теперь он передает бд, дальше сделаем маршрутизацию.
http методы по разным моделям данных, необходимо разнести по разным модулям. Создаем папку routes, в которой создаем роутеры для каждой модели данных. Добавляем файл router.js, которая будем главным маршрутизатором. Он будет вызывать нужные функции со своими маршрутами, при получения запроса с браузера. 

____________________________________________
http://localhost:5222/api/client/list
____________________________________________

функция create
/*const addClient = await Client.create({
            ham: 'Reshetov',
            rating: 3,
            age: '2006-03-05',
            role: 'user',
            createdAt: '2025-09-05',
            updatedAt: '2025-10-03'
        });*/


attributes: ['name','rating']}

___________________
1) GET/api/client/"123"/order/"456" - параметры URL
reg.params = {id:"123",orderId:"456"}

2) GET/api/clients?page="1"&limit="10&search="john"} - параметры запроса
reg.query

3) {'name'; 'IVAN'; 'rating'; '4'}
reg.body
